// 面试题 17.16 按摩师
// 一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。
// 在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，
// 替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。
// 注意：本题相对原题稍作改动
// 示例 1：
// 输入： [1,2,3,1]
// 输出： 4
// 解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。
// 示例 2：
// 输入： [2,7,9,3,1]
// 输出： 12
// 解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。
// 示例 3：
// 输入： [2,1,4,5,3,1,1,3]
// 输出： 12
// 解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。

// 先读懂题目，题目要求返回最大的总和数，并且不能用相邻的两个元素，
// 也就是取元素隔一个或者多个，只要最后结果最大就行。
// 这题很容易想到动态规划，如果知道每个子数组的的最大和，
// 那么只要比较当前这个元素加上dp[i-2]是否大于dp[i-1],如果大于那么dp[i]=dp[i-2]+nums[i],
// 小于那么当前的最大和dp[i]=dp[i-1]，遍历完那么就得到了所有得dp,
// 直接返回数组dp的最后一个元素即可。
// 动态规划的核心就是将原问题分解为一个个子问题，并且能够通过子问题等到结果。

var massage = function(nums) {
  let len = nums.length;
  if (len == 0) return 0;
  if (len == 1) return nums[0];
  let dp = new Array(len);
  dp[0] = nums[0];
  dp[1] = Math.max(nums[0], nums[1]);
  for (let i = 2; i < len; i++) {
    if (nums[i] + dp[i - 2] > dp[i - 1]) {
      dp[i] = nums[i] + dp[i - 2];
    } else {
      dp[i] = dp[i - 1];
    }
  }
  return dp[len - 1];
};

// 二、优化
var massage = function(nums) {
  let a = 0,
    b = 0;
  for (let i = 0; i < nums.length; i++) {
    let c = Math.max(b, a + nums[i]); // 前n个数最大值加nums[i] 是否大于 nums[i-1]的最大值
    a = b;
    b = c;
  }
  return b;
};

console.log(massage([1, 2, 3, 1]));
console.log(massage([2, 7, 9, 3, 1]));
console.log(massage([2, 1, 4, 5, 3, 1, 1, 3]));
